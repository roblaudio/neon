--!native
--!optimize 2
--!strict
--!nocheck
-- Server generated by Neon v0.0.0 (https://github.com/roblaudio/neon)
-- Implementation based on Zap v0.6.16 (https://github.com/red-blox/zap)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local outgoingBuff: buffer
local outgoingUsed: number
local outgoingSize: number
local outgoingInst: { Instance }
local outgoingApos: number

local incomingBuffer: buffer
local incomingRead: number
local incomingInst: { Instance }
local incomingIpos: number

-- thanks to https://dom.rojo.space/binary.html#cframe
local CFrameSpecialCases = {
	CFrame.Angles(0, 0, 0),
	CFrame.Angles(math.rad(90), 0, 0),
	CFrame.Angles(0, math.rad(180), math.rad(180)),
	CFrame.Angles(math.rad(-90), 0, 0),
	CFrame.Angles(0, math.rad(180), math.rad(90)),
	CFrame.Angles(0, math.rad(90), math.rad(90)),
	CFrame.Angles(0, 0, math.rad(90)),
	CFrame.Angles(0, math.rad(-90), math.rad(90)),
	CFrame.Angles(math.rad(-90), math.rad(-90), 0),
	CFrame.Angles(0, math.rad(-90), 0),
	CFrame.Angles(math.rad(90), math.rad(-90), 0),
	CFrame.Angles(0, math.rad(90), math.rad(180)),
	CFrame.Angles(0, math.rad(-90), math.rad(180)),
	CFrame.Angles(0, math.rad(180), math.rad(0)),
	CFrame.Angles(math.rad(-90), math.rad(-180), math.rad(0)),
	CFrame.Angles(0, math.rad(0), math.rad(180)),
	CFrame.Angles(math.rad(90), math.rad(180), math.rad(0)),
	CFrame.Angles(0, math.rad(0), math.rad(-90)),
	CFrame.Angles(0, math.rad(-90), math.rad(-90)),
	CFrame.Angles(0, math.rad(-180), math.rad(-90)),
	CFrame.Angles(0, math.rad(90), math.rad(-90)),
	CFrame.Angles(math.rad(90), math.rad(90), 0),
	CFrame.Angles(0, math.rad(90), 0),
	CFrame.Angles(math.rad(-90), math.rad(90), 0),
}

local function alloc(len: number)
	if outgoingUsed + len > outgoingSize then
		while outgoingUsed + len > outgoingSize do
			outgoingSize = outgoingSize * 2
		end

		local newBuff = buffer.create(outgoingSize)
		buffer.copy(newBuff, 0, outgoingBuff, 0, outgoingUsed)

		outgoingBuff = newBuff
	end

	outgoingApos = outgoingUsed
	outgoingUsed = outgoingUsed + len

	return outgoingApos
end

local function read(len: number)
	local pos = incomingRead
	incomingRead = incomingRead + len

	return pos
end

local function save()
	return {
		buff = outgoingBuff,
		used = outgoingUsed,
		size = outgoingSize,
		inst = outgoingInst,
	}
end

local function load(data: {
	buff: buffer,
	used: number,
	size: number,
	inst: { Instance },
})
	outgoingBuff = data.buff
	outgoingUsed = data.used
	outgoingSize = data.size
	outgoingInst = data.inst
end

local function loadEmpty()
	outgoingBuff = buffer.create(64)
	outgoingUsed = 0
	outgoingSize = 64
	outgoingInst = {}
end

loadEmpty()

local types = {}

if not RunService:IsServer() then
	error("[neon] cannot use server module from the client")
end

local remotes = ReplicatedStorage:FindFirstChild("Neon")
if remotes == nil then
	remotes = Instance.new("Folder")
	remotes.Name = "Neon"
	remotes.Parent = ReplicatedStorage
end

local reliable = remotes:FindFirstChild("Neon_Reliable")
if reliable == nil then
	reliable = Instance.new("RemoteEvent")
	reliable.Name = "Neon_Reliable"
	reliable.Parent = remotes
end

local unreliable = remotes:FindFirstChild("Neon_Unreliable")
if unreliable == nil then
	unreliable = Instance.new("UnreliableRemoteEvent")
	unreliable.Name = "Neon_Unreliable"
	unreliable.Parent = remotes
end

local Players = game:GetService("Players")

local players = {}
local function loadPlayer(player: Player)
	if players[player] then
		load(players[player])
	else
		loadEmpty()
	end
end

Players.PlayerRemoving:Connect(function(player)
	players[player] = nil
end)

local events = table.create(3)
local function sendEvents()
	for player, outgoing in players do
		if outgoing.used > 0 then
			local buff = buffer.create(outgoing.used)
			buffer.copy(buff, 0, outgoing.buff, 0, outgoing.used)
			reliable:FireClient(player, buff, outgoing.inst)
			outgoing.buff = buffer.create(64)
			outgoing.used = 0
			outgoing.size = 64
			table.clear(outgoing.inst)
		end
	end
end

RunService.PreSimulation:Connect(sendEvents)
reliable.OnServerEvent:Connect(function(player, buff, inst)
	incomingBuff = buff
	incomingInst = inst
	incomingRead = 0
	incomingIpos = 0
	local len = buffer.len(buff)
	while incoming_read < len do
		local id = buffer.readu8(buff, read(1))
		if id == 1 then
			local call_id = buffer.readu8(buff, read(1))
			local value
			if events[1] then
				task.spawn(function(player2, callId2, value1)
					local rets = events[1](player2, value1)
					loadPlayer(player2)
					alloc(1)
					buffer.writeu8(outgoingBuff, outgoingApos, 1)
					alloc(1)
					buffer.writeu8(outgoingBuff, outgoingApos, callId2)
					alloc(1)
					buffer.writeu8(outgoingBuff, outgoingApos, rets and 1 or 0)
					players[player2] = save()
				end, player, callId, value)
			end
		else
			error("[neon] unknown event id")
		end
	end
end)

return table.freeze({
	sendEvents = sendEvents,
	EventFromClient = table.freeze({
		---
		on = function() end,
	}),
	EventFromServer = table.freeze({
		---
		fire = function() end,
		---
		fireAll = function() end,
		---
		fireExcept = function() end,
		---
		fireList = function() end,
	}),
	FunctionFromServer = table.freeze({
		---
		setCallback = function() end,
	}),
})
